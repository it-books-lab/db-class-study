
# 1. NoSQL DB

<img width="2329" height="1034" alt="image" src="https://github.com/user-attachments/assets/322f1e8f-9950-4000-bf26-833cfc7b1c7f" />

<img width="2359" height="388" alt="image" src="https://github.com/user-attachments/assets/e38d43a0-bf54-4627-af7e-aeaaca5b8d2a" />



- 관계형 DB 한계와 대안으로서의 NoSQL
    - 비정형 데이터
    - 고가의 서버 확장과 용량 확대의 한계
    - 빅데이터 환경에서 요구하는 대용량 데이터의 읽기와 쓰기, 빠른 응답시간, 높은 가용성 등은 기존 SQL 데이터베이스로는 효율적으로 지원하기 어려움

## 🧩 1️⃣ 관계형 DB는 ‘비정형 데이터’를 저장할 수 없다는 한계가 있다는 말인가요?

**부분적으로 맞습니다.**

관계형 DB(RDB)는 데이터를 **표(table)** 형태로 저장하는 시스템이에요.

| id | name | email |
| --- | --- | --- |
| 1 | 홍길동 | [a@b.com](mailto:a@b.com) |
| 2 | 김철수 | [c@d.com](mailto:c@d.com) |

이런 구조처럼, **모든 데이터는 미리 정해진 스키마(열 구조)** 를 따라야 합니다.

즉, “정형 데이터(Structured Data)”에는 강하지만,

**“비정형 데이터(Unstructured Data)”에는 약합니다.**

예를 들어 👇

| 예시 | 정형 데이터 | 비정형 데이터 |
| --- | --- | --- |
| 형태 | 표, 행, 열로 명확히 구분 | JSON, 이미지, 동영상, SNS 댓글 |
| 예시 | 회원정보, 주문내역 | 블로그 글, 트윗, 센서 로그, 채팅 내용 |

→ 관계형 DB도 JSON을 문자열로 저장은 할 수 있지만,

그 내용을 효율적으로 **검색하거나 필터링하는 데는 비효율적**이에요.

그래서 이런 데이터는 **MongoDB**, **ElasticSearch**, **Cassandra** 같은 **NoSQL**이 훨씬 유리합니다.

---

## 🧩 2️⃣ "고가의 서버 확장과 용량 확대의 한계"가 관계형 DB의 한계라면, NoSQL은 비용이 더 저렴한가요?

**정확히 말하면, “확장 방식”이 다릅니다.**

### 🔹 관계형 DB는 “수직적 확장(Vertical Scaling)” 구조입니다.

- 데이터를 한 대의 **중앙 서버**(예: Oracle, MySQL)에 저장함.
- 데이터가 많아지면 CPU, 메모리, 디스크를 업그레이드해야 함.
    
    → 즉, **“한 서버를 계속 업그레이드”해야 함.**
    
- 고성능 장비일수록 **매우 비싸짐.**

📉 단점:

한 대 서버가 감당할 수 있는 **물리적 한계**가 있음 (확장에 한계 존재)

---

### 🔹 NoSQL은 “수평적 확장(Horizontal Scaling)” 구조입니다.

- 데이터를 여러 대의 **일반 서버(노드)** 로 나누어 저장함.
- 데이터가 늘어나면 **서버를 여러 대 추가**하면 됨.
    
    → 클라우드 환경에서 유연하게 확장 가능.
    
- 장비 1대는 저렴한 서버여도 괜찮음.

📈 장점:

- 확장이 자유롭고, 대규모 트래픽(수많은 사용자)을 쉽게 분산 처리.
- 장애 발생 시에도 다른 노드가 대체 가능 → **가용성(availability)** 높음.

✅ 결론:

- **NoSQL은 확장이 훨씬 쉽고, 대규모 분산 환경에 적합.**
- “비용이 무조건 저렴”하다기보다는, “비용 대비 확장 효율이 좋다”고 이해하면 정확합니다.

---

## 🧩 3️⃣ NoSQL이 무조건적으로 더 효율적이고 빠른가요?

**절대 아닙니다. ❌**

NoSQL은 **상황에 따라 더 빠르거나 더 적합한 선택**일 뿐,

모든 경우에 RDB보다 뛰어난 것은 아닙니다.

| 비교 항목 | 관계형 DB (RDB) | NoSQL |
| --- | --- | --- |
| **데이터 구조** | 정형 데이터 (스키마 고정) | 비정형 / 반정형 데이터 (유연한 스키마) |
| **확장성** | 수직적 (Scale-up) | 수평적 (Scale-out) |
| **트랜잭션(ACID)** | 강력하게 보장 | 보통 느슨하게 보장 (BASE) |
| **일관성(consistency)** | 매우 중요 (은행, 결제 등) | 경우에 따라 희생 가능 |
| **읽기/쓰기 속도** | 적당히 빠름 | 대규모 병렬처리 시 매우 빠름 |
| **대표 예시** | MySQL, PostgreSQL, Oracle | MongoDB, Redis, Cassandra |

📌 **즉, NoSQL은 효율적이지만, “조건부”로 효율적입니다.**

예를 들어:

- SNS 댓글, 로그 데이터, 채팅 기록 등 → NoSQL이 더 빠르고 효율적
- 은행 계좌, 결제, 재고 관리 등 → RDB가 더 안정적이고 정확

---

## ✅ 정리 요약

| 구분 | 관계형 DB | NoSQL |
| --- | --- | --- |
| 데이터 형태 | 정형 데이터 | 비정형 / 반정형 데이터 |
| 확장 방식 | 수직 확장 (Scale-up) | 수평 확장 (Scale-out) |
| 트랜잭션 | ACID (강한 일관성) | BASE (높은 가용성, 느슨한 일관성) |
| 강점 | 정확성, 무결성, 안정성 | 대용량 처리, 확장성, 속도 |
| 약점 | 확장 비용 높음, 비정형 데이터 비효율 | 복잡한 조인, 강한 일관성 보장 어려움 |

---

## 🧩 1️⃣ 왜 NoSQL이 “대용량 데이터에서 읽기/쓰기 빠르고, 응답시간과 가용성이 높다”고 하는가?

이건 **NoSQL의 설계 철학과 구조적인 차이** 때문이에요.

NoSQL이 “마법처럼 빠른 게” 아니라,

**정확성(Consistency)을 일부 포기하는 대신 속도와 확장성을 얻은 구조**라고 보는 게 맞습니다.

하나씩 살펴볼게요 👇

---

### 🔹 (1) **분산 구조로 설계되어 있다 (수평 확장: Scale-out)**

- NoSQL은 처음부터 **여러 서버(노드)** 에 데이터를 나눠 저장하고 처리하도록 만들어졌어요.
- 즉, 데이터를 한 대의 서버가 아니라 **여러 대가 동시에 나눠서 읽고 쓰는 구조**입니다.

📌 예시

- MySQL(관계형 DB): 한 서버가 모든 요청을 처리
- MongoDB, Cassandra(NoSQL): 서버 10대가 각자 다른 데이터를 처리 → 병렬 처리 가능

👉 결과적으로, **읽기/쓰기 속도**가 훨씬 빠름

(특히 빅데이터나 실시간 로그 처리 환경에서 효과가 큼)

---

### 🔹 (2) **데이터 구조가 유연하고, 스키마 제약이 적다**

- 관계형 DB는 데이터를 넣기 전에 **테이블 구조(스키마)** 를 먼저 정해야 함
    
    → 열의 개수, 데이터 타입 등 미리 정의 필요
    
- NoSQL은 대부분 **스키마가 유연하거나 없음**
    
    → JSON 형태로 자유롭게 넣고 뺄 수 있음
    

📌 예시

```json
{
  "user": "세민",
  "hobby": ["독서", "게임"],
  "age": 24
}

```

→ 다음번에 `"email"`을 추가해도 에러 안 남.

→ 즉, **데이터를 변환하거나 구조를 맞추는 과정이 짧아서 처리 속도가 빠름.**

---

### 🔹 (3) **일관성(Consistency)보다 가용성(Availability)을 우선시함**

- 관계형 DB는 **트랜잭션(ACID)** 을 지키기 위해
    
    모든 데이터 변경이 “완전히 일관된 상태로 저장될 때까지” 기다립니다.
    
    → 즉, “정확하지만 느림”
    
- NoSQL은 보통 **BASE 모델**을 따름
    - Basically Available (항상 접근 가능)
    - Soft state (상태가 잠시 일관되지 않을 수 있음)
    - Eventually consistent (시간이 지나면 일관성 회복됨)

👉 결과적으로,

**일시적인 불일치는 허용하되, 서비스 중단은 피함.**

즉, **빠른 응답 + 높은 가용성** 확보.

📌 예시

- 인스타그램 “좋아요 수”가 즉시 정확하지 않아도 큰 문제는 없음
- 대신 페이지가 느리게 뜨는 건 더 큰 문제
    
    → 이런 서비스는 NoSQL이 훨씬 적합함
    

---

### 🔹 (4) **단순한 쿼리 구조와 조인(Join) 없는 설계**

- 관계형 DB는 복잡한 조인(Join)으로 여러 테이블 데이터를 연결함
- NoSQL은 “한 문서(document)” 안에 모든 관련 데이터를 넣는 **중복 저장 구조**

📌 예시

```json
{
  "post_id": 1,
  "author": "세민",
  "comments": [
    {"user": "A", "text": "좋아요"},
    {"user": "B", "text": "멋져요"}
  ]
}

```

→ 댓글 데이터를 따로 테이블로 나누지 않고, **하나의 문서에 포함시킴.**

→ 조인 필요 없음 → 읽기 속도 빠름

---

### ✅ 요약: NoSQL이 빠른 이유

| 이유 | 설명 |
| --- | --- |
| **수평 확장(분산 구조)** | 여러 서버가 동시에 데이터 처리 |
| **스키마 유연성** | 구조 변환 과정이 적음 |
| **일관성보다 가용성 중시** | 일시 불일치를 허용, 빠른 응답 |
| **조인 없는 단순 구조** | 한 번의 접근으로 필요한 데이터 조회 가능 |

📌 즉, “빠름”은 “트랜잭션의 엄격함을 조금 완화한 대가”로 얻은 결과입니다.

(그래서 은행, 결제 시스템처럼 정확성이 최우선인 곳은 여전히 RDB를 사용합니다.)

---

## 🧩 2️⃣ 관계형 DB와 SQL은 같은 말인가요?

❌ **아닙니다. 전혀 다릅니다.**

두 개념은 **“DB의 종류”와 “DB를 다루는 언어”** 로 구분해야 합니다.

| 구분 | 관계형 DB (RDB) | SQL |
| --- | --- | --- |
| **의미** | 데이터를 “테이블(행, 열)” 구조로 저장하는 DB 시스템 | 관계형 DB를 조작하기 위한 언어 |
| **예시** | MySQL, PostgreSQL, Oracle, SQLite | SELECT, INSERT, UPDATE, DELETE 등 |
| **관계** | “관계형 DB”가 “SQL”을 사용함 | SQL은 “관계형 DB 전용 언어” |

📌 관계형 DB = SQL을 사용하는 DBMS

📌 하지만 **NoSQL은 SQL을 사용하지 않거나, 일부만 흉내낸 쿼리 언어**를 사용함 (그래서 이름이 *No-SQL*)

---

### ✅ 간단히 정리하자면

| 구분 | 관계형 DB (RDB) | NoSQL |
| --- | --- | --- |
| **저장 방식** | 테이블 기반 | 문서, 키-값, 그래프 등 다양 |
| **쿼리 언어** | SQL | SQL 없음 / JSON 기반 쿼리 |
| **확장 방식** | 수직적 | 수평적 |
| **트랜잭션** | 엄격한 ACID | 느슨한 BASE |
| **강점** | 정확성, 안정성 | 속도, 확장성, 유연성 |

---

# 2. SQL vs NoSQL DB

<img width="1324" height="810" alt="image" src="https://github.com/user-attachments/assets/1319993a-92cf-4453-9011-e5165209d71e" />

## 1️⃣ 무결성(Integrity)이란?

- *무결성(Integrity)**은 데이터가 **정확하고 일관되며 신뢰할 수 있는 상태**를 유지하도록 보장하는 성질이에요.

쉽게 말해서,

> “DB에 들어 있는 데이터가 말이 안 되는 상태가 되지 않도록 하는 규칙”
> 

### 예시

| 조건 | 설명 | 예시 |
| --- | --- | --- |
| **개체 무결성(Entity Integrity)** | 테이블의 각 행(row)은 고유해야 함 | `User` 테이블의 `id`는 중복될 수 없음 |
| **참조 무결성(Referential Integrity)** | 외래키로 연결된 데이터는 실제 존재해야 함 | `Order` 테이블의 `user_id`는 실제 `User` 테이블에 존재해야 함 |
| **도메인 무결성(Domain Integrity)** | 각 컬럼의 값은 유효한 범위 내에 있어야 함 | `age`는 음수가 될 수 없음 |
| **고유 무결성(Unique Integrity)** | 특정 속성은 중복될 수 없음 | `email`은 중복 불가 |

📘 즉, 무결성은 “DB 안의 데이터가 모순되지 않게 지켜주는 안전장치”라고 보면 됩니다.

---

## 2️⃣ NoSQL은 구조화되지 않은 질의어(API) 사용 — 예시로 설명

SQL에서는 항상 **정형화된 쿼리문**을 사용하죠:

```sql
SELECT name, age FROM users WHERE city = 'Seoul';

```

반면 NoSQL(MongoDB 예시)은 **프로그래밍 언어 스타일의 질의문**이나 **API 호출 형태**로 데이터를 다룹니다:

```jsx
db.users.find({ city: "Seoul" }, { name: 1, age: 1 });

```

또는 자바스크립트/Python 코드에서 바로 API 형태로 접근하기도 해요:

```python
users.find({"city": "Seoul"}, {"name": 1, "age": 1})

```

📌 즉, NoSQL은 **“SQL 문법”이 아니라 프로그래밍 함수(API) 형태로 질의**한다는 뜻이에요.

---

## 3️⃣ 외래키/조인 vs 참조(링크)/내장(임베디드)

관계형 DB는 **외래키(Foreign Key)** 로 다른 테이블을 참조하고, **JOIN**으로 연결합니다.

### 🧩 관계형 DB 예시 (SQL)

```sql
-- User 테이블
CREATE TABLE User (
  id INT PRIMARY KEY,
  name VARCHAR(50)
);

-- Post 테이블
CREATE TABLE Post (
  id INT PRIMARY KEY,
  user_id INT,
  content TEXT,
  FOREIGN KEY (user_id) REFERENCES User(id)
);

-- 조회 (조인)
SELECT u.name, p.content
FROM User u
JOIN Post p ON u.id = p.user_id;

```

➡️ “유저”와 “게시글”을 다른 테이블에 나누고, `JOIN`으로 연결합니다.

---

### 🧱 NoSQL 예시 (MongoDB)

NoSQL에서는 테이블이 아니라 **문서(document)** 로 저장돼요.

### (1) **참조(링크)** 방식

```json
{
  "id": 1,
  "name": "세민",
  "posts": [1, 2, 3]  // 다른 문서(Post)를 가리키는 참조 ID
}

```

➡️ SQL의 외래키와 유사하지만, **명시적인 관계 제약**은 없음.

### (2) **내장(임베디드)** 방식

```json
{
  "id": 1,
  "name": "세민",
  "posts": [
    { "id": 1, "content": "안녕하세요!" },
    { "id": 2, "content": "NoSQL 공부 중입니다." }
  ]
}

```

➡️ 게시글 데이터를 **유저 문서 내부에 직접 포함(Embedded)**

→ JOIN이 필요 없고, 읽기가 훨씬 빠름.

---

## 4️⃣ “소셜미디어”와 “로그 데이터”란?

### ✅ 소셜미디어(Social Media)

- 사용자가 콘텐츠(글, 사진, 동영상 등)를 올리고 서로 소통하는 서비스.
- 예: 인스타그램, 트위터(X), 페이스북, 유튜브
- **데이터 특징:** 매우 **다양하고 비정형적(사진, 댓글, 좋아요 등)** → NoSQL이 잘 맞음.

예시 (비정형 데이터)

```json
{
  "user": "세민",
  "content": "오늘은 DB 공부 중!",
  "likes": 120,
  "tags": ["database", "NoSQL", "study"],
  "image": "https://..."
}

```

---

### ✅ 로그(Log) 데이터

- 시스템이 동작하면서 자동으로 남기는 기록 (서버, 앱, 보안 등)
- 예: 누가, 언제, 어떤 요청을 보냈는지 기록하는 데이터

예시 (로그)

```json
{
  "timestamp": "2025-10-05T10:30:22",
  "userId": 123,
  "action": "LOGIN",
  "ip": "192.168.1.10",
  "device": "Chrome on Windows"
}

```

➡️ 이런 로그는 **초당 수천~수만 건**씩 쌓이기 때문에

**빠른 쓰기 성능 + 확장성**이 중요한데, NoSQL이 이 부분에서 유리합니다.

---

## 💡 정리 요약

| 구분 | SQL (관계형 DB) | NoSQL |
| --- | --- | --- |
| 데이터 구조 | 정형적 (테이블, 스키마 고정) | 유연함 (JSON, 문서 등) |
| 관계 표현 | 외래키 + JOIN | 참조(Link) 또는 내장(Embedded) |
| 질의 방법 | SQL 문법 | API, 함수 호출 |
| 무결성 | 강함 (제약 조건) | 약함 (자유로운 구조 허용) |
| 확장성 | 수직적 (서버 성능 향상) | 수평적 (서버 추가) |
| 사용 예시 | 은행, 쇼핑몰, 결제시스템 | 소셜미디어, 로그, IoT |

---

# 3. NoSQL DB 유형

<img width="1081" height="514" alt="image" src="https://github.com/user-attachments/assets/c1004f15-3a1d-4ba7-a202-ac2f3bc1d031" />

<img width="1482" height="509" alt="image" src="https://github.com/user-attachments/assets/9c02305f-1392-49f0-a77e-c806a3945933" />

<img width="845" height="276" alt="image" src="https://github.com/user-attachments/assets/ef207e61-50ac-46b5-a464-ec4c687b8d72" />

<img width="1632" height="596" alt="image" src="https://github.com/user-attachments/assets/444f435d-76e5-422c-a499-629881edd6ea" />

<img width="621" height="281" alt="image" src="https://github.com/user-attachments/assets/779c0388-aaea-4630-b50f-98da77cfa21e" />

<img width="1606" height="484" alt="image" src="https://github.com/user-attachments/assets/a93e274e-cea8-46ba-9de1-dc0db1e0dd79" />

<img width="890" height="313" alt="image" src="https://github.com/user-attachments/assets/0b2e72f1-5f14-4232-b05d-7d1889ba117d" />

<img width="1513" height="318" alt="image" src="https://github.com/user-attachments/assets/85cb9c01-c6df-419c-a5eb-3fbb0073c45b" />

<img width="771" height="362" alt="image" src="https://github.com/user-attachments/assets/d29b5a28-fe5a-4b37-977b-88bbf91c93a7" />


- 키-값 데이터베이스
    - 장점: 데이터 분할 가능, 다른 DB로는 불가능한 수준까지 수평적 확장이 가능
    - 단점: 특정값 검색에는 효율적이지만, 데이터 정렬, 그룹화, 범위 검색 등이 어려움
- 문서 데이터베이스
    - 반구조적 데이터의 저장과 검색에 사용
    - ‘키-문서’ 데이터베이스 형태(키에 대응하는 값이 문서)로 키에 대응하는 각각의 문서는 속성과 속성에 대응하는 데이터를 가짐
    - 문서는 반구조화된 데이터 형태로 계층적 구조를 가지며 객체와 유사하게 하나의 단위로 취급(JSON이나 XML 문서 등)
    - 스키마가 자주 바뀌거나 저장할 데이터가 복잡한 계층 구조를 가질 경우 또 문서 간의 비교보다는 문서 자체의 검색과 변경이 대부분일 경우 효과적

---

## 🧩 1️⃣ 키-값(Key–Value) 데이터베이스

### 🧠 개념

- 데이터를 **“하나의 키(key)”** 와 **“그에 대응하는 값(value)”** 으로 저장합니다.
- 대표 예시: **Redis**, **Amazon DynamoDB**, **Riak**

---

### 💾 예시 (Redis 스타일)

```bash
SET user:1001 "세민"
GET user:1001

```

➡️ `"user:1001"` 이 **키**, `"세민"` 이 **값**이에요.

DB에는 단순히 키와 값만 저장되어 있습니다.

---

### 💡 응용 예시 (JSON 값)

값이 문자열 하나가 아니라 JSON 형태로도 가능해요:

```bash
SET user:1002 '{"name": "세민", "age": 25, "city": "Seoul"}'
GET user:1002

```

➡️ Redis 내부에선 **이 전체 JSON이 단순한 “문자열 값”**으로 저장됩니다.

즉, **“name이 세민인 모든 사람” 같은 조건 검색은 불가능**합니다.

오직 키(`user:1002`)로만 검색할 수 있어요.

---

### ✅ 장점

- 키로 빠르게 찾을 수 있음 (O(1) 시간 복잡도)
- 수평 확장이 쉬움 (서버를 여러 대 추가해도 구조가 단순함)

### ❌ 단점

- “나이가 25세 이상인 유저 조회”처럼 **조건 검색/정렬/그룹화가 불가능**
- 단순 캐시, 세션, 임시 저장소로 적합함

---

## 📄 2️⃣ 문서(Document) 데이터베이스

### 🧠 개념

- 하나의 데이터 단위를 **문서(document)** 로 저장하고,
    
    문서 내부에 **속성(key)** 과 **값(value)** 을 계층적으로 포함할 수 있습니다.
    
- 대표 예시: **MongoDB**, **CouchDB**, **Firebase Firestore**

---

### 💾 예시 (MongoDB 스타일)

```jsx
{
  "_id": 1,
  "name": "세민",
  "age": 25,
  "address": {
    "city": "Seoul",
    "zip": "04524"
  },
  "hobbies": ["coding", "music", "travel"]
}

```

➡️ 하나의 문서(document)는 **JSON 구조**를 가집니다.

`address`처럼 **객체 중첩(계층 구조)** 가능하고,

`hobbies`처럼 **리스트(배열)** 도 저장할 수 있죠.

---

### 🔍 문서 검색 예시

```jsx
// age가 20 이상인 사람 조회
db.users.find({ age: { $gte: 20 } });

// city가 Seoul인 사람 조회
db.users.find({ "address.city": "Seoul" });

```

➡️ 키-값 DB와 달리, **문서 내부의 속성까지 검색 가능!**

---

### 🔄 문서 수정 예시

```jsx
db.users.updateOne(
  { name: "세민" },
  { $set: { "address.city": "Busan" } }
);

```

➡️ 문서 구조가 유연해서, 언제든 필드를 추가/수정할 수 있습니다.

(스키마가 고정되지 않음)

---

### ✅ 장점

| 항목 | 설명 |
| --- | --- |
| **반구조적 데이터 지원** | JSON, XML 등 계층 구조로 표현 가능 |
| **스키마 유연성** | 필드를 자유롭게 추가/삭제 가능 |
| **검색 가능** | 문서 내부의 속성까지 쿼리 가능 |
| **읽기 빠름** | 문서 전체를 한 번에 읽음 (JOIN 불필요) |

### ❌ 단점

| 항목 | 설명 |
| --- | --- |
| **복잡한 관계 표현 어려움** | RDB처럼 JOIN이 없음 |
| **데이터 중복 발생 가능** | 문서 안에 다른 문서를 내장하면 중복될 수 있음 |
| **일관성(Consistency) 약함** | 여러 문서를 동시에 수정할 때 주의 필요 |

---

## 🧮 비교 정리

| 구분 | 키-값 DB | 문서 DB |
| --- | --- | --- |
| 데이터 형태 | Key:Value 쌍 | JSON / XML 문서 |
| 예시 | Redis, DynamoDB | MongoDB, CouchDB |
| 검색 방식 | 키로만 검색 | 문서 내부 속성 검색 가능 |
| 구조 | 단순 (Flat) | 계층적 (Nested) |
| 스키마 변경 | 불필요 | 매우 유연 |
| 사용 예 | 세션 캐시, 게임 순위표, 임시 데이터 | 사용자 정보, 제품 카탈로그, 게시글 저장 |

---

## 📘 예시로 느껴보기

| 상황 | 적합한 DB | 이유 |
| --- | --- | --- |
| 로그인한 사용자 세션 정보를 저장 | **Redis (Key-Value)** | 단순 키로 빠르게 찾기 |
| 사용자 프로필 (이름, 주소, 취미 등) 저장 | **MongoDB (Document)** | JSON처럼 다양한 구조 |
| 상품 리뷰, 댓글, 태그를 포함한 게시글 | **Document DB** | 반구조적이고 계층적 데이터 |
| 쇼핑몰 결제 내역, 은행 거래 정보 | **관계형 SQL DB** | 트랜잭션, 무결성이 중요 |

---

## ✅ 1️⃣ “반구조적 데이터” vs “비정형 데이터” vs “구조적 데이터”

이 세 가지는 **데이터가 얼마나 체계적으로 구조화되어 있는가**의 차이예요.

| 구분 | 형태 | 특징 | 예시 |
| --- | --- | --- | --- |
| **구조적(Structured)** | 테이블 형태 (행·열 고정) | 스키마(열 이름, 자료형 등)가 명확히 정의됨 | 관계형 DB의 `SQL 테이블`, 엑셀 |
| **반구조적(Semi-Structured)** | 계층적 구조(JSON, XML) | 스키마가 느슨함 — 같은 컬렉션 안에서도 필드가 다를 수 있음 | JSON, XML, YAML |
| **비정형(Unstructured)** | 형식 없음 | 고정된 구조나 스키마가 전혀 없음 | 이미지, 동영상, 오디오, 이메일 본문 |

---

### 📘 예시로 구분 보기

### 🟩 구조적 데이터 (Structured)

SQL 테이블 예시:

| id | name | age | city |
| --- | --- | --- | --- |
| 1 | 세민 | 25 | 서울 |
| 2 | 민지 | 28 | 부산 |

→ 모든 행(row)이 **같은 열(column) 구조를 공유**하고, 데이터 타입도 정해져 있음.

---

### 🟨 반구조적 데이터 (Semi-Structured)

JSON 예시:

```json
[
  { "name": "세민", "age": 25, "city": "서울" },
  { "name": "민지", "job": "개발자" }
]

```

→ `첫 번째 객체`에는 `age`가 있고,

`두 번째 객체`에는 `job`이 있음.

즉, **공통된 스키마 없이도 데이터가 존재 가능**.

✅ 그래서 JSON, XML은 “반(半) 구조적 데이터”라고 부릅니다.

---

### 🟥 비정형 데이터 (Unstructured)

예시:

- 이미지 파일 (`.jpg`)
- 동영상 (`.mp4`)
- 녹음 파일 (`.mp3`)
- 자연어 텍스트 (자유롭게 쓴 글)

→ 정해진 형식이 전혀 없음.

→ DB에 넣으려면 보통 **메타데이터(이름, 태그 등)** 로만 일부 관리함.

---

### 💡 정리 요약

| 구분 | 스키마 존재 여부 | 예시 | 주로 사용하는 DB |
| --- | --- | --- | --- |
| 구조적 | 엄격히 고정 | SQL 테이블 | 관계형 DB |
| 반구조적 | 느슨하거나 동적 | JSON, XML | 문서형 NoSQL (MongoDB 등) |
| 비정형 | 없음 | 이미지, 영상, 로그 | 파일 저장소, 객체 스토리지 |

---

## ✅ 2️⃣ “문서의 구조 = 키와 속성의 관계” 혼동 정리

좋아요, 여기서 헷갈린 부분은 아주 핵심이에요 👍

강의자료에서

> “각 문서는 속성과 속성에 대응하는 데이터를 가진다”
> 
> 
> 라고 되어 있는데,
> 
> 이건 결국 **문서(document)** 내부 구조가 **‘키-값(key-value)’의 모음**이라는 뜻이에요.
> 

즉,

- 문서 데이터베이스 전체로 보면 “키–문서” 구조
- 문서 내부로 들어가면 “속성–값(=키–값)” 구조

예시로 보면 확실해요 👇

```json
// 문서 데이터베이스의 한 문서(document)
{
  "_id": 1001,            // 문서의 고유 키 (MongoDB 자동 생성)
  "name": "세민",         // 속성(key)과 값(value)
  "age": 25,
  "address": {
    "city": "Seoul",
    "zipcode": "04524"
  }
}

```

정리하자면:

- **DB 전체 관점:** “문서 1개 = 하나의 데이터 단위”
- **문서 내부 관점:** “문서 안에는 여러 개의 속성(key–value 쌍) 존재”

즉, **“키-문서 구조” 위에 “문서 내부는 키-값 구조”로 구성**된다고 보면 돼요.

---

## ✅ 3️⃣ 문서 간의 비교에 유리한 건? → 관계형 SQL DB

네, 아주 정확하게 짚으셨어요 👏

문서 데이터베이스는 **각 문서(document)** 가 독립적인 단위로 저장돼요.

그래서 “문서 간 비교”나 “관계 연산”은 **관계형 DB**가 훨씬 유리합니다.

---

### 📊 예시로 비교

### 🧱 문서형 DB (MongoDB)

```json
[
  { "user": "세민", "score": 90 },
  { "user": "규서", "score": 85 }
]

```

> “모든 사용자 평균 점수보다 높은 사용자”
> 
> 
> 이런 걸 하려면?
> 
- NoSQL에서는 **두 단계로 나눠서 수동으로 처리해야** 합니다.
    
    1️⃣ 전체 평균 계산
    
    2️⃣ 조건에 맞는 문서만 필터링
    

→ 집계는 가능하지만, 문서 간 직접 비교는 어렵습니다.

---

### 🧩 관계형 DB (SQL)

```sql
SELECT user, score
FROM users
WHERE score > (SELECT AVG(score) FROM users);

```

➡️ SQL에서는 **서브쿼리(Subquery)** 로

**“데이터 간 비교”를 매우 효율적으로 수행**할 수 있죠.

---

### 💡 결론

| 기능 | 문서형 DB (NoSQL) | 관계형 DB (SQL) |
| --- | --- | --- |
| 데이터 단위 | 문서(JSON) | 행(row) |
| 관계 표현 | 약함 (독립 문서) | 강함 (JOIN, FK 등) |
| 문서 간 비교 | 어렵고 비효율적 | SQL 문법으로 직접 가능 |
| 활용 예시 | 개별 객체 조회, 단일 문서 수정 | 통계, 비교, 관계 분석 |

---

## 🧠 정리 한 줄 요약

| 질문 | 핵심 요약 |
| --- | --- |
| 1️⃣ 반구조적이란? | 완전히 자유로운 비정형은 아니지만, 스키마가 느슨한 JSON/XML 형태 |
| 2️⃣ 문서 내부 구조는? | 문서(DB 전체의 단위)는 “키–문서”, 문서 안은 “속성–값” 구조 |
| 3️⃣ 문서 간 비교는? | 관계형 DB(SQL)가 훨씬 효율적 (JOIN, 서브쿼리 등 지원) |

---

# 4. MongoDB 특징과 특성

<img width="882" height="213" alt="image" src="https://github.com/user-attachments/assets/9dde09ec-eab4-49b2-96d0-142c3eb218fc" />

<img width="1496" height="673" alt="image" src="https://github.com/user-attachments/assets/7c82b2f1-97f1-4e6b-9af1-4a98455376e4" />



### **1️⃣ “오픈소스”의 의미**

> 💬 “MongoDB는 오픈소스 DBMS이다”
> 
- *오픈소스(Open Source)**란

→ **소스 코드(프로그램의 설계도)가 공개되어 누구나 열람·수정·배포할 수 있는 소프트웨어**를 뜻합니다.

✅ **즉, “무료”일 수도 있지만 “무료 = 오픈소스”는 아닙니다.**

| 구분 | 설명 |
| --- | --- |
| **오픈소스** | 소스코드가 공개되어 있고, 자유롭게 수정·배포 가능 (예: MongoDB, MySQL, PostgreSQL 등) |
| **무료(Freeware)** | 사용은 무료지만, 소스코드는 비공개 (예: VS Code, Discord 등 일부 프로그램) |

> MongoDB의 경우 커뮤니티 버전은 무료지만,
> 
> 
> **엔터프라이즈 버전(MongoDB Atlas 등)**은 관리 도구나 백업, 보안 기능이 추가된 **유료 서비스**입니다.
> 

---

### **2️⃣ “단순함, 속도, 확장성” — 왜 SQL보다 단순한가요?**

맞아요! 정확히 짚으셨습니다 👍

MongoDB가 단순하다고 불리는 이유는 다음과 같습니다.

| 비교 항목 | **SQL DB** | **MongoDB (NoSQL)** |
| --- | --- | --- |
| **데이터 구조** | 엄격한 스키마 필요 (테이블 정의 필수) | 자유로운 문서 구조(JSON) |
| **관계 표현** | JOIN으로 여러 테이블 연결 | 문서 안에 중첩 구조로 한 번에 저장 |
| **데이터 추가** | 스키마 변경 시 테이블 수정 필요 | 기존 필드 외 새 필드 추가도 바로 가능 |
| **무결성 제약** | 외래키, 제약조건으로 강제 | 유연 — 데이터 무결성은 애플리케이션 레벨에서 관리 |
| **확장성** | 수직적 확장(서버 성능 업그레이드) 중심 | 수평적 확장(서버 여러 대로 나누기) 쉬움 |

즉,

👉 스키마 설계, JOIN, 제약조건 등에서 자유로워서 “단순”하다고 표현합니다.

👉 대신 “유연한 만큼 개발자가 규칙을 직접 잘 지켜야” 합니다.

---

### **3️⃣ 복제(Replication)와 샤딩(Sharding)**

> 💬 “복제와 샤딩을 통한 가용성의 향상”
> 

### 🔹 복제(Replication)

👉 데이터를 **여러 서버에 복사**해서 저장하는 것.

하나의 서버가 죽어도 다른 서버에서 데이터를 제공할 수 있어 **가용성(Availability)**이 높아집니다.

예시 (MongoDB Replica Set):

```
Primary (기본 서버)
 ├── Secondary 1 (복제본)
 └── Secondary 2 (복제본)

```

- Primary가 다운되면 Secondary 중 하나가 자동으로 승격됩니다.

→ SQL에서도 복제가 가능하지만, MongoDB는 이 기능이 **내장되어 기본적으로 지원**합니다.

---

### 🔹 샤딩(Sharding)

👉 데이터를 **여러 서버(Shard)**에 나누어 저장하는 기법입니다.

예시로 사용자 데이터를 ID 기준으로 분산 저장한다고 하면:

| Shard | 데이터 범위 |
| --- | --- |
| Shard 1 | user_id 1 ~ 1,000,000 |
| Shard 2 | user_id 1,000,001 ~ 2,000,000 |
| Shard 3 | user_id 2,000,001 ~ 3,000,000 |

➡️ 이렇게 나누면

- 각 서버가 담당하는 데이터량이 줄어들고,
- 동시에 여러 서버에서 쿼리를 처리할 수 있어서
    
    **읽기/쓰기 속도가 빨라지고 확장성(Scalability)**이 향상됩니다.
    

🟢 SQL도 샤딩이 **가능은** 하지만,

- **애플리케이션 레벨에서 직접 구현**해야 하고
- **JOIN, 트랜잭션, 제약조건 관리가 복잡**해집니다.
    
    반면 MongoDB는 샤딩 기능이 **기본 내장되어 자동 분산 관리**가 가능합니다.
    

---

### ✅ 요약 정리

| 개념 | 설명 | SQL보다 유리한 이유 |
| --- | --- | --- |
| **오픈소스** | 소스코드가 공개된 프로그램 | 커뮤니티 중심 개발, 자유로운 수정 |
| **단순함** | 스키마, JOIN, 제약조건의 유연함 | 빠른 개발, 구조 변경 용이 |
| **복제(Replication)** | 데이터 여러 서버에 복사 | 서버 장애 시 자동 복구 |
| **샤딩(Sharding)** | 데이터를 여러 서버에 분산 저장 | 대용량 데이터 처리, 수평 확장 쉬움 |

---

# 5. MongoDB 구조와 내부 계층 구조

<img width="1454" height="605" alt="image" src="https://github.com/user-attachments/assets/87553617-250a-40dc-864b-27472739289e" />

<img width="1387" height="682" alt="image" src="https://github.com/user-attachments/assets/beb6c71d-e20d-474a-b40e-1b274ec16d00" />


MongoDB는 설치하고 실행하면 **자동으로 `admin`, `local`, `config` 데이터베이스를 생성**합니다.

이건 사용자가 만든 게 아니라 **MongoDB 서버가 내부 용도로 사용하는 시스템 데이터베이스**예요.

하나씩 정리해드릴게요 👇

---

### 🗂️ MongoDB의 기본 내장 데이터베이스 3개

| DB 이름 | 용도 | 주요 특징 |
| --- | --- | --- |
| **`admin`** | **관리 및 권한 제어용** | - “루트 데이터베이스”로, 관리 명령어(`createUser`, `shutdown`, `serverStatus` 등)를 실행할 수 있음- 관리자는 보통 이 DB에서 생성됨 |
| **`local`** | **복제(Replication) 관련 데이터 저장용** | - **각 서버(노드)**마다 고유하게 존재함 (복제 세트 간 공유되지 않음)- oplog(작업 로그)가 저장되어, 복제 시 변경 내역을 추적함 |
| **`config`** | **샤딩(Sharding) 관련 설정용** | - 샤딩 클러스터 환경에서 **데이터 분할 정보**(어떤 shard에 어떤 데이터가 있는지)를 저장함- 일반 단일 서버(Mongod)에서는 거의 비어 있음 |

---

### 🧠 추가 설명

- **`show dbs`** 명령을 바로 실행하면,
    
    이 DB들이 안 보일 수도 있습니다.
    
    (기본적으로 **데이터가 존재하는 DB만 표시**하기 때문이에요.)
    
    예시:
    
    ```bash
    > show dbs
    admin     0.000GB
    local     0.000GB
    config    0.000GB
    test      0.001GB
    
    ```
    
- 그러나 `use admin` 같이 명령으로 직접 접근하면 항상 존재합니다.

---

### 💡 정리

| 이름 | 자동 생성 여부 | 역할 |
| --- | --- | --- |
| `admin` | ✅ 예 | 사용자 권한, 관리 명령 |
| `local` | ✅ 예 | 복제 로그(oplog) |
| `config` | ✅ 예 | 샤딩 메타데이터 |

---

<img width="1389" height="666" alt="image" src="https://github.com/user-attachments/assets/6abd9bed-9a0b-4b89-837a-b21c742d6abf" />



# 6. 문서 데이터 모델

<img width="1391" height="696" alt="image" src="https://github.com/user-attachments/assets/a0b49118-1c4a-46ed-a8ce-6f38361c0774" />



# 7. JSON vs BSON

<img width="1503" height="656" alt="image" src="https://github.com/user-attachments/assets/4caa4ecd-2e6c-437e-9cce-bd8f9bfe7154" />


# 8. MongoDB의 동적 스키마

<img width="1419" height="330" alt="image" src="https://github.com/user-attachments/assets/35ffbbe4-155d-4590-8e35-dd25d536407f" />


# 9. MongoDB의 관계 표현

<img width="1337" height="677" alt="image" src="https://github.com/user-attachments/assets/4320fdad-603d-41b1-abca-b2438e73a59d" />


# 10. MongoDB와 관계형DB 구조 비교

<img width="1365" height="589" alt="image" src="https://github.com/user-attachments/assets/d24acba6-509e-40e9-92e0-7d140b1422db" />


# 11. MongoDB 실습



